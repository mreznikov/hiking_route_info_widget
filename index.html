<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>IsraelHiking.org.il Route Details Fetcher</title>
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
    <style>
        body { font-family: sans-serif; padding: 10px; background-color: #f0f0f0; color: #333; }
        #status { margin-top: 10px; padding: 8px; background-color: #fff; border-radius: 4px; min-height: 40px; white-space: pre-wrap; border: 1px solid #ddd; }
        .processing { color: #007bff; }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .warning { color: #ffc107; }
        p { font-size: 0.9em; }
    </style>
</head>
<body>
    <h3>Получение данных маршрута с IsraelHiking.org.il</h3>
    <p>Выберите строку в таблице или измените ссылку в колонке 'R' для загрузки деталей маршрута.</p>
    <div id="status">Ожидание выбора записи...</div>

    <script>
        // === НАЧАЛО СКРИПТА - ЛОГ ВЕРСИИ ===
        const WIDGET_VERSION = "v2.0.0";
        console.log(`DEBUG: Grist IsraelHiking Details Fetcher Загружен - Версия ${WIDGET_VERSION}`);

        // === ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ===
        let currentTable1Id = null; 
        
        // ID колонок в Table1
        const URL_COL_ID = "R";                 // Колонка со ссылкой на israelhiking.osm.org.il
        const DISTANCE_COL_ID = "AD";           // Колонка для общей дистанции (км)
        const ASCENT_COL_ID = "AE";             // Колонка для общего подъема (м)
        const DESCENT_COL_ID = "AF";            // Колонка для общего спуска (м)

        const statusDiv = document.getElementById('status');

        /**
         * Загружает и парсит данные маршрута со страницы IsraelHiking.org.il.
         * @param {string} routeUrl - URL страницы маршрута.
         * @returns {Promise<object|null>} Объект с данными { distance, ascent, descent } или null в случае ошибки.
         */
        async function fetchRouteDetailsFromPage(routeUrl) {
            if (!routeUrl || !routeUrl.startsWith("https://israelhiking.osm.org.il/share/")) {
                console.warn("Неверный URL или URL не от israelhiking.osm.org.il/share/");
                statusDiv.textContent = "Ошибка: Неверный формат URL.";
                statusDiv.className = 'error';
                return null;
            }

            statusDiv.textContent = `Загрузка данных с ${routeUrl}...`;
            statusDiv.className = 'processing';
            console.log(`DEBUG: Попытка загрузить HTML с: ${routeUrl}`);

            try {
                // ВНИМАНИЕ: Этот запрос, скорее всего, будет заблокирован CORS в браузере!
                const response = await fetch(routeUrl); 
                
                if (!response.ok) {
                    throw new Error(`Ошибка сети при загрузке страницы: ${response.status} ${response.statusText}`);
                }
                const htmlText = await response.text();
                console.log("DEBUG: HTML страницы успешно загружен (длина:", htmlText.length, ")");

                // Парсим HTML для поиска нужного скрипта
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlText, "text/html");
                const scriptElement = doc.getElementById('route-details-data');

                if (!scriptElement || !scriptElement.textContent) {
                    console.error("Не найден элемент <script id='route-details-data'> или он пуст.");
                    statusDiv.textContent = "Ошибка: Не удалось найти данные о маршруте на странице.";
                    statusDiv.className = 'error';
                    return null;
                }

                const jsonDataString = scriptElement.textContent;
                console.log("DEBUG: Извлечен JSON string:", jsonDataString.substring(0, 200) + "..."); // Логируем начало JSON

                const routeData = JSON.parse(jsonDataString);
                console.log("DEBUG: Распарсен JSON:", routeData);

                if (routeData && typeof routeData.length === 'number' && typeof routeData.ascent === 'number' && typeof routeData.descent === 'number') {
                    const distanceKm = (routeData.length / 1000).toFixed(1); // В км, один знак после запятой
                    statusDiv.textContent = `Данные получены: Дистанция ${distanceKm} км, Подъем ${routeData.ascent} м, Спуск ${routeData.descent} м.`;
                    statusDiv.className = 'success';
                    return {
                        distance: parseFloat(distanceKm),
                        ascent: routeData.ascent,
                        descent: routeData.descent
                    };
                } else {
                    console.error("JSON не содержит ожидаемых полей length, ascent, descent или они не являются числами.");
                    statusDiv.textContent = "Ошибка: Неверный формат данных о маршруте на странице.";
                    statusDiv.className = 'error';
                    return null;
                }

            } catch (error) {
                console.error("ОШИБКА при загрузке или парсинге данных маршрута:", error);
                if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                     statusDiv.textContent = "ОШИБКА: Не удалось загрузить данные с сайта. Вероятно, это проблема CORS. Проверьте консоль разработчика (F12).";
                } else {
                    statusDiv.textContent = `ОШИБКА: ${error.message}`;
                }
                statusDiv.className = 'error';
                return null;
            }
        }

        /**
         * Обработчик выбора/изменения записи в Table1.
         */
        async function handleTable1Record(record, mappings) {
            if (!record || !record.id) {
                statusDiv.textContent = "Запись не выбрана.";
                statusDiv.className = '';
                return;
            }
            console.log("DEBUG: Выбрана/изменена запись в Table1:", record);

            const routeUrl = record[URL_COL_ID];
            if (!routeUrl) {
                statusDiv.textContent = `В колонке '${URL_COL_ID}' нет URL для записи ID ${record.id}.`;
                statusDiv.className = 'warning';
                // Очищаем поля, если URL был удален
                const clearPayload = {
                    [DISTANCE_COL_ID]: null,
                    [ASCENT_COL_ID]: null,
                    [DESCENT_COL_ID]: null
                };
                try {
                    await grist.docApi.applyUserActions([['UpdateRecord', currentTable1Id, record.id, clearPayload]]);
                    console.log(`DEBUG: Очищены поля для записи ID ${record.id} из-за отсутствия URL.`);
                } catch(e) {
                    console.error("Ошибка при очистке полей:", e);
                }
                return;
            }

            // Проверяем, нужно ли обновлять (если URL изменился или данные отсутствуют)
            const oldDistance = record[DISTANCE_COL_ID];
            const oldAscent = record[ASCENT_COL_ID];
            const oldDescent = record[DESCENT_COL_ID];

            // Мы будем делать запрос, если URL есть и хотя бы одно из полей пустое
            // или если URL изменился (это отслеживается самим grist.onRecord)
            // Для простоты, если URL есть, всегда пытаемся получить данные,
            // а записываем, только если они отличаются или были пустыми.

            const routeDetails = await fetchRouteDetailsFromPage(routeUrl);

            if (routeDetails) {
                const updatePayload = {};
                let needsUpdate = false;

                if (routeDetails.distance !== oldDistance) {
                    updatePayload[DISTANCE_COL_ID] = routeDetails.distance;
                    needsUpdate = true;
                }
                if (routeDetails.ascent !== oldAscent) {
                    updatePayload[ASCENT_COL_ID] = routeDetails.ascent;
                    needsUpdate = true;
                }
                if (routeDetails.descent !== oldDescent) {
                    updatePayload[DESCENT_COL_ID] = routeDetails.descent;
                    needsUpdate = true;
                }
                
                // Принудительное обновление, если старые значения были пустыми, а новые есть
                if (oldDistance === null && typeof routeDetails.distance === 'number') needsUpdate = true;
                if (oldAscent === null && typeof routeDetails.ascent === 'number') needsUpdate = true;
                if (oldDescent === null && typeof routeDetails.descent === 'number') needsUpdate = true;


                if (needsUpdate && Object.keys(updatePayload).length > 0) {
                    try {
                        console.log(`DEBUG: Обновление записи ID ${record.id} в ${currentTable1Id} данными:`, updatePayload);
                        await grist.docApi.applyUserActions([['UpdateRecord', currentTable1Id, record.id, updatePayload]]);
                        statusDiv.innerHTML += `<br>Данные для маршрута ID ${record.id} обновлены в Grist.`;
                        statusDiv.className = 'success';
                    } catch (e) {
                        console.error("ОШИБКА при обновлении записи в Grist:", e);
                        statusDiv.textContent = `Ошибка записи данных в Grist: ${e.message}`;
                        statusDiv.className = 'error';
                    }
                } else if (Object.keys(updatePayload).length === 0 && !needsUpdate) {
                     console.log(`DEBUG: Данные для записи ID ${record.id} не изменились. Обновление Grist не требуется.`);
                     statusDiv.innerHTML += `<br>Данные для маршрута ID ${record.id} не изменились.`;
                }
            }
        }

        async function initGrist() {
            console.log("DEBUG: initGrist() called");
            if (typeof grist === 'undefined' || !grist.ready) {
                console.error("Grist API не найден."); statusDiv.textContent = "Ошибка: Grist API не найден."; return;
            }

            try {
                await grist.ready({
                    requiredAccess: 'full',
                    columns: [ 
                        { name: URL_COL_ID, type: 'Text' },
                        { name: DISTANCE_COL_ID, type: 'Numeric', optional: true },
                        { name: ASCENT_COL_ID, type: 'Numeric', optional: true },
                        { name: DESCENT_COL_ID, type: 'Numeric', optional: true },
                    ]
                });
                console.log("DEBUG: grist.ready() завершен.");

                grist.onOptions(async (options, interaction) => {
                    console.log("DEBUG: grist.onOptions - options:", options, "interaction:", interaction);
                    let tableIdFromOptions = (options?.tableId) || (interaction?.tableId) || null;
                    
                    if (tableIdFromOptions) {
                        currentTable1Id = tableIdFromOptions;
                    } else if (grist.selectedTable && typeof grist.selectedTable.getTableId === 'function') {
                        try {
                            currentTable1Id = await grist.selectedTable.getTableId();
                        } catch (e) {
                            console.error("Ошибка при вызове grist.selectedTable.getTableId():", e);
                        }
                    }

                    if (currentTable1Id) {
                        console.log(`DEBUG: ID основной таблицы (Table1) установлен: ${currentTable1Id}`);
                    } else {
                        console.error("ОШИБКА КРИТИЧЕСКАЯ: ID основной таблицы (Table1) НЕ УСТАНОВЛЕН. Убедитесь, что виджет привязан к таблице в настройках.");
                        statusDiv.textContent = "Ошибка конфигурации: виджет не связан с таблицей.";
                    }
                });
                
                // Вызываем grist.onOptions один раз для инициализации currentTable1Id, если возможно
                // Grist должен вызвать onOptions при загрузке виджета
                // Если grist.onOptions не вызывается автоматически при первой загрузке, это может быть проблемой
                // для определения currentTable1Id до первого onRecord.
                // Однако, onRecord передает record, который содержит tableId.
                
                grist.onRecord(async (record, mappings) => {
                    if (record && record.id && mappings && mappings.tableId) {
                        currentTable1Id = mappings.tableId; // Обновляем ID таблицы из mappings
                        console.log(`DEBUG: ID таблицы из mappings.tableId: ${currentTable1Id}`);
                        await handleTable1Record(record, mappings);
                    } else if (record && record.id && currentTable1Id) {
                        // Если mappings не содержит tableId, но currentTable1Id уже установлен
                        await handleTable1Record(record, mappings);
                    } else {
                        console.warn("DEBUG: onRecord вызван, но record, record.id или tableId отсутствуют.", record, mappings);
                        statusDiv.textContent = "Ожидание выбора записи...";
                    }
                }); 
                console.log(`DEBUG: Установлен обработчик grist.onRecord.`);
                
                console.log(`DEBUG: Grist API настроен и готов. Версия виджета: ${WIDGET_VERSION}`);
                statusDiv.textContent = "Виджет готов. Выберите строку или измените URL в колонке 'R'.";

            } catch (err) {
                console.error("Ошибка при grist.ready() или начальной настройке:", err);
                statusDiv.textContent = "Ошибка инициализации виджета.";
            }
        }
        initGrist();
    </script>
</body>
</html>
